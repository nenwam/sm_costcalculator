{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar DefineOwnProperty = require('../helpers/DefineOwnProperty');\nvar isPropertyDescriptor = require('../helpers/isPropertyDescriptor');\nvar isSamePropertyDescriptor = require('../helpers/isSamePropertyDescriptor');\nvar FromPropertyDescriptor = require('./FromPropertyDescriptor');\nvar IsAccessorDescriptor = require('./IsAccessorDescriptor');\nvar IsDataDescriptor = require('./IsDataDescriptor');\nvar IsGenericDescriptor = require('./IsGenericDescriptor');\nvar IsPropertyKey = require('./IsPropertyKey');\nvar SameValue = require('./SameValue');\nvar Type = require('./Type');\n\n// https://262.ecma-international.org/6.0/#sec-validateandapplypropertydescriptor\n// https://262.ecma-international.org/8.0/#sec-validateandapplypropertydescriptor\n\n// eslint-disable-next-line max-lines-per-function, max-statements\nmodule.exports = function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {\n  // this uses the ES2017+ logic, since it fixes a number of bugs in the ES2015 logic.\n  var oType = Type(O);\n  if (oType !== 'Undefined' && oType !== 'Object') {\n    throw new $TypeError('Assertion failed: O must be undefined or an Object');\n  }\n  if (Type(extensible) !== 'Boolean') {\n    throw new $TypeError('Assertion failed: extensible must be a Boolean');\n  }\n  if (!isPropertyDescriptor({\n    Type: Type,\n    IsDataDescriptor: IsDataDescriptor,\n    IsAccessorDescriptor: IsAccessorDescriptor\n  }, Desc)) {\n    throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');\n  }\n  if (Type(current) !== 'Undefined' && !isPropertyDescriptor({\n    Type: Type,\n    IsDataDescriptor: IsDataDescriptor,\n    IsAccessorDescriptor: IsAccessorDescriptor\n  }, current)) {\n    throw new $TypeError('Assertion failed: current must be a Property Descriptor, or undefined');\n  }\n  if (oType !== 'Undefined' && !IsPropertyKey(P)) {\n    throw new $TypeError('Assertion failed: if O is not undefined, P must be a Property Key');\n  }\n  if (Type(current) === 'Undefined') {\n    if (!extensible) {\n      return false;\n    }\n    if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {\n      if (oType !== 'Undefined') {\n        DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, {\n          '[[Configurable]]': Desc['[[Configurable]]'],\n          '[[Enumerable]]': Desc['[[Enumerable]]'],\n          '[[Value]]': Desc['[[Value]]'],\n          '[[Writable]]': Desc['[[Writable]]']\n        });\n      }\n    } else {\n      if (!IsAccessorDescriptor(Desc)) {\n        throw new $TypeError('Assertion failed: Desc is not an accessor descriptor');\n      }\n      if (oType !== 'Undefined') {\n        return DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, Desc);\n      }\n    }\n    return true;\n  }\n  if (IsGenericDescriptor(Desc) && !('[[Configurable]]' in Desc) && !('[[Enumerable]]' in Desc)) {\n    return true;\n  }\n  if (isSamePropertyDescriptor({\n    SameValue: SameValue\n  }, Desc, current)) {\n    return true; // removed by ES2017, but should still be correct\n  }\n  // \"if every field in Desc is absent, return true\" can't really match the assertion that it's a Property Descriptor\n  if (!current['[[Configurable]]']) {\n    if (Desc['[[Configurable]]']) {\n      return false;\n    }\n    if ('[[Enumerable]]' in Desc && !Desc['[[Enumerable]]'] === !!current['[[Enumerable]]']) {\n      return false;\n    }\n  }\n  if (IsGenericDescriptor(Desc)) {\n    // no further validation is required.\n  } else if (IsDataDescriptor(current) !== IsDataDescriptor(Desc)) {\n    if (!current['[[Configurable]]']) {\n      return false;\n    }\n    if (IsDataDescriptor(current)) {\n      if (oType !== 'Undefined') {\n        DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, {\n          '[[Configurable]]': current['[[Configurable]]'],\n          '[[Enumerable]]': current['[[Enumerable]]'],\n          '[[Get]]': undefined\n        });\n      }\n    } else if (oType !== 'Undefined') {\n      DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, {\n        '[[Configurable]]': current['[[Configurable]]'],\n        '[[Enumerable]]': current['[[Enumerable]]'],\n        '[[Value]]': undefined\n      });\n    }\n  } else if (IsDataDescriptor(current) && IsDataDescriptor(Desc)) {\n    if (!current['[[Configurable]]'] && !current['[[Writable]]']) {\n      if ('[[Writable]]' in Desc && Desc['[[Writable]]']) {\n        return false;\n      }\n      if ('[[Value]]' in Desc && !SameValue(Desc['[[Value]]'], current['[[Value]]'])) {\n        return false;\n      }\n      return true;\n    }\n  } else if (IsAccessorDescriptor(current) && IsAccessorDescriptor(Desc)) {\n    if (!current['[[Configurable]]']) {\n      if ('[[Set]]' in Desc && !SameValue(Desc['[[Set]]'], current['[[Set]]'])) {\n        return false;\n      }\n      if ('[[Get]]' in Desc && !SameValue(Desc['[[Get]]'], current['[[Get]]'])) {\n        return false;\n      }\n      return true;\n    }\n  } else {\n    throw new $TypeError('Assertion failed: current and Desc are not both data, both accessors, or one accessor and one data.');\n  }\n  if (oType !== 'Undefined') {\n    return DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, Desc);\n  }\n  return true;\n};","map":{"version":3,"names":["GetIntrinsic","require","$TypeError","DefineOwnProperty","isPropertyDescriptor","isSamePropertyDescriptor","FromPropertyDescriptor","IsAccessorDescriptor","IsDataDescriptor","IsGenericDescriptor","IsPropertyKey","SameValue","Type","module","exports","ValidateAndApplyPropertyDescriptor","O","P","extensible","Desc","current","oType","undefined"],"sources":["/home/nenwam/Documents/rallyessentials/cost_calculator/quickstart-react/node_modules/es-abstract/2021/ValidateAndApplyPropertyDescriptor.js"],"sourcesContent":["'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\n\nvar DefineOwnProperty = require('../helpers/DefineOwnProperty');\nvar isPropertyDescriptor = require('../helpers/isPropertyDescriptor');\nvar isSamePropertyDescriptor = require('../helpers/isSamePropertyDescriptor');\n\nvar FromPropertyDescriptor = require('./FromPropertyDescriptor');\nvar IsAccessorDescriptor = require('./IsAccessorDescriptor');\nvar IsDataDescriptor = require('./IsDataDescriptor');\nvar IsGenericDescriptor = require('./IsGenericDescriptor');\nvar IsPropertyKey = require('./IsPropertyKey');\nvar SameValue = require('./SameValue');\nvar Type = require('./Type');\n\n// https://262.ecma-international.org/6.0/#sec-validateandapplypropertydescriptor\n// https://262.ecma-international.org/8.0/#sec-validateandapplypropertydescriptor\n\n// eslint-disable-next-line max-lines-per-function, max-statements\nmodule.exports = function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {\n\t// this uses the ES2017+ logic, since it fixes a number of bugs in the ES2015 logic.\n\tvar oType = Type(O);\n\tif (oType !== 'Undefined' && oType !== 'Object') {\n\t\tthrow new $TypeError('Assertion failed: O must be undefined or an Object');\n\t}\n\tif (Type(extensible) !== 'Boolean') {\n\t\tthrow new $TypeError('Assertion failed: extensible must be a Boolean');\n\t}\n\tif (!isPropertyDescriptor({\n\t\tType: Type,\n\t\tIsDataDescriptor: IsDataDescriptor,\n\t\tIsAccessorDescriptor: IsAccessorDescriptor\n\t}, Desc)) {\n\t\tthrow new $TypeError('Assertion failed: Desc must be a Property Descriptor');\n\t}\n\tif (Type(current) !== 'Undefined' && !isPropertyDescriptor({\n\t\tType: Type,\n\t\tIsDataDescriptor: IsDataDescriptor,\n\t\tIsAccessorDescriptor: IsAccessorDescriptor\n\t}, current)) {\n\t\tthrow new $TypeError('Assertion failed: current must be a Property Descriptor, or undefined');\n\t}\n\tif (oType !== 'Undefined' && !IsPropertyKey(P)) {\n\t\tthrow new $TypeError('Assertion failed: if O is not undefined, P must be a Property Key');\n\t}\n\tif (Type(current) === 'Undefined') {\n\t\tif (!extensible) {\n\t\t\treturn false;\n\t\t}\n\t\tif (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {\n\t\t\tif (oType !== 'Undefined') {\n\t\t\t\tDefineOwnProperty(\n\t\t\t\t\tIsDataDescriptor,\n\t\t\t\t\tSameValue,\n\t\t\t\t\tFromPropertyDescriptor,\n\t\t\t\t\tO,\n\t\t\t\t\tP,\n\t\t\t\t\t{\n\t\t\t\t\t\t'[[Configurable]]': Desc['[[Configurable]]'],\n\t\t\t\t\t\t'[[Enumerable]]': Desc['[[Enumerable]]'],\n\t\t\t\t\t\t'[[Value]]': Desc['[[Value]]'],\n\t\t\t\t\t\t'[[Writable]]': Desc['[[Writable]]']\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!IsAccessorDescriptor(Desc)) {\n\t\t\t\tthrow new $TypeError('Assertion failed: Desc is not an accessor descriptor');\n\t\t\t}\n\t\t\tif (oType !== 'Undefined') {\n\t\t\t\treturn DefineOwnProperty(\n\t\t\t\t\tIsDataDescriptor,\n\t\t\t\t\tSameValue,\n\t\t\t\t\tFromPropertyDescriptor,\n\t\t\t\t\tO,\n\t\t\t\t\tP,\n\t\t\t\t\tDesc\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tif (IsGenericDescriptor(Desc) && !('[[Configurable]]' in Desc) && !('[[Enumerable]]' in Desc)) {\n\t\treturn true;\n\t}\n\tif (isSamePropertyDescriptor({ SameValue: SameValue }, Desc, current)) {\n\t\treturn true; // removed by ES2017, but should still be correct\n\t}\n\t// \"if every field in Desc is absent, return true\" can't really match the assertion that it's a Property Descriptor\n\tif (!current['[[Configurable]]']) {\n\t\tif (Desc['[[Configurable]]']) {\n\t\t\treturn false;\n\t\t}\n\t\tif ('[[Enumerable]]' in Desc && !Desc['[[Enumerable]]'] === !!current['[[Enumerable]]']) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (IsGenericDescriptor(Desc)) {\n\t\t// no further validation is required.\n\t} else if (IsDataDescriptor(current) !== IsDataDescriptor(Desc)) {\n\t\tif (!current['[[Configurable]]']) {\n\t\t\treturn false;\n\t\t}\n\t\tif (IsDataDescriptor(current)) {\n\t\t\tif (oType !== 'Undefined') {\n\t\t\t\tDefineOwnProperty(\n\t\t\t\t\tIsDataDescriptor,\n\t\t\t\t\tSameValue,\n\t\t\t\t\tFromPropertyDescriptor,\n\t\t\t\t\tO,\n\t\t\t\t\tP,\n\t\t\t\t\t{\n\t\t\t\t\t\t'[[Configurable]]': current['[[Configurable]]'],\n\t\t\t\t\t\t'[[Enumerable]]': current['[[Enumerable]]'],\n\t\t\t\t\t\t'[[Get]]': undefined\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (oType !== 'Undefined') {\n\t\t\tDefineOwnProperty(\n\t\t\t\tIsDataDescriptor,\n\t\t\t\tSameValue,\n\t\t\t\tFromPropertyDescriptor,\n\t\t\t\tO,\n\t\t\t\tP,\n\t\t\t\t{\n\t\t\t\t\t'[[Configurable]]': current['[[Configurable]]'],\n\t\t\t\t\t'[[Enumerable]]': current['[[Enumerable]]'],\n\t\t\t\t\t'[[Value]]': undefined\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t} else if (IsDataDescriptor(current) && IsDataDescriptor(Desc)) {\n\t\tif (!current['[[Configurable]]'] && !current['[[Writable]]']) {\n\t\t\tif ('[[Writable]]' in Desc && Desc['[[Writable]]']) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ('[[Value]]' in Desc && !SameValue(Desc['[[Value]]'], current['[[Value]]'])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t} else if (IsAccessorDescriptor(current) && IsAccessorDescriptor(Desc)) {\n\t\tif (!current['[[Configurable]]']) {\n\t\t\tif ('[[Set]]' in Desc && !SameValue(Desc['[[Set]]'], current['[[Set]]'])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ('[[Get]]' in Desc && !SameValue(Desc['[[Get]]'], current['[[Get]]'])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\tthrow new $TypeError('Assertion failed: current and Desc are not both data, both accessors, or one accessor and one data.');\n\t}\n\tif (oType !== 'Undefined') {\n\t\treturn DefineOwnProperty(\n\t\t\tIsDataDescriptor,\n\t\t\tSameValue,\n\t\t\tFromPropertyDescriptor,\n\t\t\tO,\n\t\t\tP,\n\t\t\tDesc\n\t\t);\n\t}\n\treturn true;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}